# Design Patterns in Go

Design patterns เป็นแนวทางการแก้ปัญหาที่พบบ่อยในการออกแบบซอฟต์แวร์ แบ่งออกเป็น 3 กลุ่มหลักตาม Gang of Four (GoF)

## 1. Creational Patterns

รูปแบบการสร้างอ็อบเจ็กต์ที่ยืดหยุ่นและสามารถนำกลับมาใช้ใหม่ได้

### 1.1 Singleton Pattern
- **วัตถุประสงค์**: รับประกันว่าคลาสจะมีอินสแตนซ์เดียวเท่านั้น และให้จุดเข้าถึงแบบ global
- **Use Cases**:
  - Database connections
  - Configuration settings
  - Logging services
- **ข้อดี**:
  - ควบคุมการเข้าถึงทรัพยากรที่ใช้ร่วมกัน
  - ประหยัดทรัพยากรระบบ
- **ข้อเสีย**:
  - ทำให้การทดสอบยากขึ้น
  - ละเมิดหลัก Single Responsibility Principle

### 1.2 Factory Pattern
- **วัตถุประสงค์**: สร้างอ็อบเจ็กต์โดยไม่ต้องเปิดเผยตรรกะการสร้าง
- **Use Cases**:
  - การสร้างอ็อบเจ็กต์ที่มีเงื่อนไขซับซ้อน
  - เมื่อต้องการทำงานกับอ็อบเจ็กต์ผ่านอินเตอร์เฟซร่วม
- **ข้อดี**:
  - แยกโค้ดการสร้างอ็อบเจ็กต์ออกจากโค้ดที่ใช้งาน
  - ง่ายต่อการขยายระบบ
- **ข้อเสีย**:
  - อาจทำให้โค้ดซับซ้อนขึ้นหากมีคลาสย่อยจำนวนมาก

### 1.3 Builder Pattern
- **วัตถุประสงค์**: แยกการสร้างอ็อบเจ็กต์ที่ซับซ้อนออกจากการแสดงผล
- **Use Cases**:
  - สร้างอ็อบเจ็กต์ที่มีพารามิเตอร์จำนวนมาก
  - ต้องการสร้างอ็อบเจ็กต์ในรูปแบบที่แตกต่างกัน
- **ข้อดี**:
  - สร้างอ็อบเจ็กต์ทีละขั้นตอน
  - นำโค้ดกลับมาใช้ใหม่ได้
- **ข้อเสีย**:
  - ต้องสร้างคลาสเพิ่มขึ้นหลายคลาส

## 2. Structural Patterns

รูปแบบการจัดการโครงสร้างของคลาสและอ็อบเจ็กต์

### 2.1 Adapter Pattern
- **วัตถุประสงค์**: ทำให้อินเตอร์เฟซที่เข้ากันไม่ได้สามารถทำงานร่วมกันได้
- **Use Cases**:
  - เชื่อมต่อกับ legacy code
  - ทำงานกับ library ภายนอก
- **ข้อดี**:
  - เพิ่มความยืดหยุ่นในการใช้งานคลาส
  - แยกโค้ดส่วนที่ปรับแต่งออกจากโค้ดหลัก
- **ข้อเสีย**:
  - เพิ่มความซับซ้อนของโค้ด

### 2.2 Decorator Pattern
- **วัตถุประสงค์**: เพิ่มความสามารถให้กับอ็อบเจ็กต์แบบไดนามิก
- **Use Cases**:
  - เพิ่มฟังก์ชันการทำงานโดยไม่ต้องแก้ไขโค้ดเดิม
  - ต้องการเพิ่มคุณสมบัติแบบยืดหยุ่น
- **ข้อดี**:
  - เพิ่มฟังก์ชันได้แบบยืดหยุ่น
  - ไม่ต้องแก้ไขโค้ดเดิม
- **ข้อเสีย**:
  - อาจมีคลาส decorator จำนวนมาก
  - ลำดับการ decorate มีผลต่อผลลัพธ์

### 2.3 Facade Pattern
- **วัตถุประสงค์**: สร้างอินเตอร์เฟซที่ง่ายขึ้นสำหรับระบบย่อยที่ซับซ้อน
- **Use Cases**:
  - ซ่อนความซับซ้อนของระบบ
  - สร้างชั้นการเข้าถึงระบบย่อย
- **ข้อดี**:
  - ลดความซับซ้อนในการใช้งานระบบ
  - แยกโค้ดผู้ใช้จากระบบย่อย
- **ข้อเสีย**:
  - อาจกลายเป็น god object
  - อาจซ่อนฟังก์ชันที่จำเป็นบางอย่าง

## 3. Behavioral Patterns

รูปแบบการจัดการพฤติกรรมและการสื่อสารระหว่างอ็อบเจ็กต์

### 3.1 Observer Pattern
- **วัตถุประสงค์**: กำหนดการพึ่งพาแบบหนึ่งต่อหลาย เมื่ออ็อบเจ็กต์หนึ่งเปลี่ยนแปลง อ็อบเจ็กต์อื่นๆ จะได้รับการแจ้งเตือน
- **Use Cases**:
  - Event handling systems
  - Real-time data monitoring
- **ข้อดี**:
  - Loose coupling ระหว่าง subject และ observer
  - รองรับการ broadcast
- **ข้อเสีย**:
  - Observers อาจพลาดการแจ้งเตือน
  - อาจเกิด memory leaks

### 3.2 Strategy Pattern
- **วัตถุประสงค์**: กำหนดชุดของอัลกอริทึมที่สามารถสลับเปลี่ยนกันได้
- **Use Cases**:
  - ระบบการชำระเงินที่หลากหลาย
  - การเลือกใช้อัลกอริทึมที่แตกต่างกัน
- **ข้อดี**:
  - สลับเปลี่ยนอัลกอริทึมได้ในระหว่างรันไทม์
  - แยกอัลกอริทึมออกจากโค้ดที่ใช้งาน
- **ข้อเสีย**:
  - เพิ่มจำนวนอ็อบเจ็กต์ในระบบ
  - ผู้ใช้ต้องรู้ความแตกต่างระหว่างกลยุทธ์

### 3.3 Chain of Responsibility Pattern
- **วัตถุประสงค์**: ส่งคำขอผ่านห่วงโซ่ของตัวจัดการจนกว่าจะมีตัวใดตัวหนึ่งจัดการมัน
- **Use Cases**:
  - ระบบ logging ที่มีหลายระดับ
  - ระบบการอนุมัติที่มีหลายขั้นตอน
- **ข้อดี**:
  - ลดการเชื่อมต่อระหว่างผู้ส่งและผู้รับ
  - เพิ่มความยืดหยุ่นในการกำหนดลำดับการจัดการ
- **ข้อเสีย**:
  - ไม่รับประกันว่าคำขอจะถูกจัดการ
  - อาจเกิดการวนซ้ำที่ไม่สิ้นสุด

## การเลือกใช้ Design Patterns

1. **พิจารณาปัญหา**:
   - ระบุปัญหาที่ต้องการแก้ไข
   - วิเคราะห์ความต้องการของระบบ

2. **เลือก Pattern ที่เหมาะสม**:
   - พิจารณาข้อดีและข้อเสียของแต่ละ pattern
   - คำนึงถึงผลกระทบต่อระบบในระยะยาว

3. **การนำไปใช้**:
   - ปรับใช้ pattern ให้เหมาะกับบริบทของโปรแกรม
   - ไม่จำเป็นต้องใช้ pattern ทุกครั้ง

4. **การประเมินผล**:
   - ตรวจสอบว่า pattern ช่วยแก้ปัญหาได้จริง
   - พิจารณาผลกระทบต่อประสิทธิภาพและการบำรุงรักษา

## สรุป

Design Patterns เป็นเครื่องมือที่มีประโยชน์ในการออกแบบซอฟต์แวร์ แต่ไม่ใช่ยาวิเศษที่จะแก้ปัญหาได้ทุกอย่าง การเลือกใช้ pattern ที่เหมาะสมและการประยุกต์ใช้อย่างถูกต้องจะช่วยให้โค้ดมีคุณภาพดีขึ้น บำรุงรักษาง่าย และยืดหยุ่นต่อการเปลี่ยนแปลงในอนาคต
